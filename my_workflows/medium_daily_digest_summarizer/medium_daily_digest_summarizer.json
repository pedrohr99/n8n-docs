
{
  "name": "Medium Daily Digest Summarizer",
  "nodes": [
    {
      "parameters": {
        "mode": "cron",
        "cronExpression": "30 9 * * *",
        "timezone": "Europe/Madrid"
      },
      "id": "schedule-trigger-node",
      "name": "Daily Schedule",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "getAll",
        "returnAll": false,
        "limit": 1,
        "filters": {
          "query": "from:noreply@medium.com to:pedroh.r99@gmail.com subject:\"Daily Digest\" is:unread",
          "receivedAfter": "={{ $now.minus({ days: 1 }).toISO() }}"
        },
        "format": "full"
      },
      "id": "gmail-fetch-node",
      "name": "Fetch Medium Digest",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "email-exists-condition",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "rightType": "any"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-email-exists",
      "name": "Check Email Exists",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract article links from Medium Daily Digest email HTML\nconst emailData = $input.all();\n\nif (!emailData || emailData.length === 0) {\n  return [];\n}\n\nconst results = [];\n\nfor (const email of emailData) {\n  const htmlContent = email.json.payload?.parts?.find(part => part.mimeType === 'text/html')?.body?.data;\n  \n  if (!htmlContent) {\n    console.log('No HTML content found in email');\n    continue;\n  }\n  \n  // Decode base64 HTML content\n  const decodedHtml = Buffer.from(htmlContent, 'base64').toString('utf-8');\n  \n  // Extract Medium article links using regex\n  // Look for links that contain medium.com and appear to be article URLs\n  const linkRegex = /https:\\/\\/[^\\s\"'<>]*medium\\.com\\/[^\\s\"'<>]*[a-f0-9]{12}/gi;\n  const matches = decodedHtml.match(linkRegex) || [];\n  \n  // Remove duplicates and filter valid article URLs\n  const uniqueLinks = [...new Set(matches)]\n    .filter(link => {\n      // Filter out non-article URLs (like profile pages, topic pages, etc.)\n      return !link.includes('/tag/') && \n             !link.includes('/topics/') && \n             !link.includes('/@') && \n             link.includes('-');\n    })\n    .slice(0, 10); // Limit to 10 articles to avoid rate limiting\n  \n  console.log(`Found ${uniqueLinks.length} unique Medium article links`);\n  \n  // Create separate items for each link\n  uniqueLinks.forEach((link, index) => {\n    results.push({\n      json: {\n        articleUrl: link,\n        emailId: email.json.id,\n        emailSubject: email.json.payload?.headers?.find(h => h.name === 'Subject')?.value || 'Medium Daily Digest',\n        emailDate: email.json.payload?.headers?.find(h => h.name === 'Date')?.value || new Date().toISOString(),\n        articleIndex: index + 1\n      }\n    });\n  });\n}\n\nreturn results;"
      },
      "id": "extract-links-node",
      "name": "Extract Article Links",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {
          "reset": false
        }
      },
      "id": "split-batch-node",
      "name": "Process Articles One by One",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.articleUrl }}",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxTries": 3
          },
          "redirect": {
            "enabled": true,
            "maxRedirects": 5
          }
        },
        "requestHeaders": {
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
            }
          ]
        }
      },
      "id": "fetch-article-node",
      "name": "Fetch Article Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "options": {}
      },
      "id": "wait-node",
      "name": "Rate Limit Wait",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract article title and content, then create summary\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const html = item.json.data || '';\n  const articleUrl = item.json.articleUrl;\n  \n  if (!html) {\n    results.push({\n      json: {\n        ...item.json,\n        title: 'Unable to fetch article',\n        summary: 'Could not retrieve article content.',\n        error: 'No HTML content received'\n      }\n    });\n    continue;\n  }\n  \n  try {\n    // Extract title - try multiple selectors\n    let title = '';\n    const titleMatches = [\n      html.match(/<title[^>]*>([^<]+)<\\/title>/i),\n      html.match(/<h1[^>]*>([^<]+)<\\/h1>/i),\n      html.match(/<meta[^>]*property=[\"']og:title[\"'][^>]*content=[\"']([^\"']+)[\"']/i),\n      html.match(/<meta[^>]*name=[\"']title[\"'][^>]*content=[\"']([^\"']+)[\"']/i)\n    ];\n    \n    for (const match of titleMatches) {\n      if (match && match[1]) {\n        title = match[1].trim();\n        // Clean up title\n        title = title.replace(/\\s*\\|\\s*Medium$/, '').replace(/\\s*â€”\\s*Medium$/, '').trim();\n        break;\n      }\n    }\n    \n    if (!title) {\n      title = 'Medium Article';\n    }\n    \n    // Extract article content - look for common Medium selectors\n    let content = '';\n    const contentMatches = [\n      html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i),\n      html.match(/<div[^>]*class=[\"'][^\"']*article[^\"']*[\"'][^>]*>([\\s\\S]*?)<\\/div>/i),\n      html.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i)\n    ];\n    \n    for (const match of contentMatches) {\n      if (match && match[1]) {\n        content = match[1];\n        break;\n      }\n    }\n    \n    if (!content) {\n      // Fallback: extract all paragraph content\n      const paragraphs = html.match(/<p[^>]*>([\\s\\S]*?)<\\/p>/gi) || [];\n      content = paragraphs.slice(0, 10).join(' '); // First 10 paragraphs\n    }\n    \n    // Clean HTML tags and extract text\n    const cleanText = content\n      .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n      .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n      .replace(/<[^>]+>/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .trim();\n    \n    // Create summary (first 2-3 sentences or ~200 characters)\n    let summary = '';\n    if (cleanText) {\n      const sentences = cleanText.match(/[^.!?]+[.!?]+/g) || [];\n      if (sentences.length >= 2) {\n        summary = sentences.slice(0, 3).join(' ').trim();\n      } else {\n        summary = cleanText.substring(0, 200).trim();\n        if (summary.length === 200 && cleanText.length > 200) {\n          summary += '...';\n        }\n      }\n    }\n    \n    if (!summary) {\n      summary = 'Unable to extract article summary from content.';\n    }\n    \n    results.push({\n      json: {\n        ...item.json,\n        title: title,\n        summary: summary,\n        wordCount: cleanText.split(' ').length,\n        extractedAt: new Date().toISOString()\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error processing article:', error);\n    results.push({\n      json: {\n        ...item.json,\n        title: 'Processing Error',\n        summary: 'An error occurred while processing this article.',\n        error: error.message\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "summarize-article-node",
      "name": "Extract Title & Summarize",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "articles",
        "options": {}
      },
      "id": "merge-articles-node",
      "name": "Collect All Articles",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "jsCode": "// Generate markdown file with all articles\nconst items = $input.all();\n\nif (!items || items.length === 0) {\n  return [{\n    json: {\n      fileName: `medium_digest_${new Date().toISOString().split('T')[0]}.md`,\n      content: '# Medium Daily Digest\\n\\nNo articles found in today\\'s digest.',\n      articleCount: 0\n    }\n  }];\n}\n\nconst articles = items[0].json.articles || [];\nconst today = new Date();\nconst dateStr = today.toISOString().split('T')[0];\nconst formattedDate = today.toLocaleDateString('en-US', { \n  weekday: 'long', \n  year: 'numeric', \n  month: 'long', \n  day: 'numeric' \n});\n\n// Create markdown content\nlet markdown = `# Medium Daily Digest - ${formattedDate}\\n\\n`;\nmarkdown += `*Generated on ${today.toISOString()}*\\n\\n`;\nmarkdown += `Found ${articles.length} articles in today's digest:\\n\\n`;\nmarkdown += '---\\n\\n';\n\n// Add each article\narticles.forEach((article, index) => {\n  markdown += `## ${index + 1}. ${article.title}\\n\\n`;\n  markdown += `**Summary:** ${article.summary}\\n\\n`;\n  markdown += `**Link:** [Read on Medium](${article.articleUrl})\\n\\n`;\n  \n  if (article.wordCount) {\n    markdown += `*Estimated reading: ~${Math.ceil(article.wordCount / 200)} minutes*\\n\\n`;\n  }\n  \n  markdown += '---\\n\\n';\n});\n\n// Add footer\nmarkdown += `\\n*This digest was automatically generated by n8n workflow.*\\n`;\nmarkdown += `*Total articles processed: ${articles.length}*\\n`;\n\nconst fileName = `medium_digest_${dateStr}.md`;\n\nreturn [{\n  json: {\n    fileName: fileName,\n    content: markdown,\n    articleCount: articles.length,\n    generatedAt: today.toISOString(),\n    articles: articles\n  }\n}];"
      },
      "id": "create-markdown-node",
      "name": "Create Markdown File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2220, 300]
    },
    {
      "parameters": {
        "resource": "file",
        "operation": "upload",
        "name": "={{ $json.fileName }}",
        "resolveData": true,
        "options": {
          "parents": {
            "parentIds": [
              "medium_com"
            ]
          }
        }
      },
      "id": "upload-to-drive-node",
      "name": "Upload to Google Drive",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [2440, 300]
    },
    {
      "parameters": {
        "content": "=Medium Daily Digest workflow completed successfully!\\n\\nFile: {{ $json.name }}\\nArticles processed: {{ $('Create Markdown File').item.json.articleCount }}\\nUploaded to Google Drive at: {{ $json.webViewLink }}",
        "options": {}
      },
      "id": "success-message-node",
      "name": "Success Notification",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2660, 300]
    },
    {
      "parameters": {
        "content": "=No Medium Daily Digest email found for today.\\n\\nThis could mean:\\n- No digest was sent today\\n- The email was already processed (marked as read)\\n- The email is in a different folder\\n\\nWorkflow will try again tomorrow.",
        "options": {}
      },
      "id": "no-email-message-node",
      "name": "No Email Found",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [680, 500]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.error }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "exists"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "error"
            }
          ]
        },
        "options": {}
      },
      "id": "error-handler-node",
      "name": "Error Handler",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [2440, 500]
    },
    {
      "parameters": {
        "content": "=Medium Daily Digest workflow encountered an error:\\n\\nError: {{ $json.error }}\\nStep: {{ $json.step || 'Unknown' }}\\nTime: {{ $now.toISO() }}\\n\\nPlease check the workflow execution for details.",
        "options": {}
      },
      "id": "error-notification-node",
      "name": "Error Notification",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2660, 500]
    }
  ],
  "connections": {
    "Daily Schedule": {
      "main": [
        [
          {
            "node": "Fetch Medium Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Medium Digest": {
      "main": [
        [
          {
            "node": "Check Email Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Email Exists": {
      "main": [
        [
          {
            "node": "Extract Article Links",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Email Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Article Links": {
      "main": [
        [
          {
            "node": "Process Articles One by One",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Articles One by One": {
      "main": [
        [
          {
            "node": "Fetch Article Content",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collect All Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Article Content": {
      "main": [
        [
          {
            "node": "Rate Limit Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit Wait": {
      "main": [
        [
          {
            "node": "Extract Title & Summarize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Title & Summarize": {
      "main": [
        [
          {
            "node": "Process Articles One by One",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect All Articles": {
      "main": [
        [
          {
            "node": "Create Markdown File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Markdown File": {
      "main": [
        [
          {
            "node": "Upload to Google Drive",
            "type": "main",
            "index": 0
          },
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Google Drive": {
      "main": [
        [
          {
            "node": "Success Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Error Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "enabled": false
    }
  },
  "staticData": {},
  "tags": [
    {
      "createdAt": "2025-01-01T00:00:00.000Z",
      "updatedAt": "2025-01-01T00:00:00.000Z",
      "id": "medium-automation",
      "name": "Medium Automation"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "1"
}
